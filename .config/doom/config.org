#+title: Yet Another Literate Configuration
#+author: Evan Riley
#+PROPERTY: header-args :tangle-mode

* About

[[emacs.sexy][Emacs]] has consumed me. It is the primary way I interact with a computer these days.

I use [[https://github.com/doomemacs/doomemacs][Doom Emacs]] as a base for this literate configuraiton.

Feel free to look around and steal what you may find interesting, copying this file as a whole though may leave you with a terrible experience...but I'm an idiot and dumb things happen in here.

* Table of Contents :QUOTE:TOC_3:
#+BEGIN_QUOTE
- [[#about][About]]
- [[#doom-modules][Doom Modules]]
- [[#configuration][Configuration]]
  - [[#header][Header]]
  - [[#global-constants][Global Constants]]
    - [[#shell][Shell]]
    - [[#contact-info][Contact Info]]
    - [[#authinfogpg][Authinfo.gpg]]
    - [[#somewhat-sensible-defaults][(Somewhat) Sensible Defaults]]
    - [[#emacsclient][Emacsclient]]
    - [[#customizations][Customizations]]
  - [[#visual-settings][Visual Settings]]
    - [[#font][Font]]
    - [[#theme][Theme]]
    - [[#remove-titlebar][Remove titlebar]]
    - [[#line-numbers][Line Numbers]]
    - [[#dashboard][Dashboard]]
  - [[#company][Company]]
  - [[#editing][Editing]]
  - [[#org-mode][Org-Mode]]
    - [[#general][General]]
    - [[#capture][Capture]]
    - [[#org-roam2][Org-Roam(2)]]
  - [[#languages][Languages]]
    - [[#python][Python]]
    - [[#go][Go]]
#+END_QUOTE

* Doom Modules

This file controls what doom modules are enabled. Doom does a lot of lazy loading so you can enable a considerable amount without fear of performance loss.

If this is changed remember to run =doom sync= or =doom/reload=.

This section in particular will be tangled into the ~init.el~ file.

#+begin_src emacs-lisp :tangle init.el
(doom! :input
       ;;bidi              ; (tfel ot) thgir etirw uoy gnipleh
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       (company           ; the ultimate code completion backend
        +childframe
        +tng)
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       ;;ivy               ; a search engine for love and life
       (vertico           ; the search engine of the future
        +icons)

       :ui
       deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       ;;doom-quit         ; DOOM quit-message prompts when you quit Emacs
       (emoji +unicode)  ; ðŸ™‚
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       ;;hydra
       ;;indent-guides     ; highlighted indent columns
       ligatures         ; ligatures and symbols to make your code pretty again
       ;;minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
       nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       unicode           ; extended unicode support for various languages
       (vc-gutter +pretty) ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       ;;window-select     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       ;;zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       (format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       parinfer          ; turn lisp into python, sort of
       rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       ;;word-wrap         ; soft wrapping with language-aware indent

       :emacs
       (dired             ; making dired pretty [functional]
        +icons)
       electric          ; smarter, keyword-based electric-indent
       ;;ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       ;;eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       vterm             ; the best terminal emulation in Emacs

       :checkers
       (syntax              ; tasing you for every semicolon you forget
        +childframe)
       ;;(spell +flyspell) ; tasing you for misspelling mispelling
       ;;grammar           ; tasing grammar mistake every you make

       :tools
       ;;ansible
       ;;biblio            ; Writes a PhD for you (citation needed)
       ;;collab            ; buffers with friends
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       direnv
       ;;docker
       editorconfig      ; let someone else argue about tabs vs spaces
       ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       lookup              ; navigate your code and its documentation
       (lsp)               ; M-x vscode
       (magit             ; a git porcelain for Emacs
        +forge)
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       ;;taskrunner        ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       tree-sitter       ; syntax and parsing, sitting in a tree...
       ;;upload            ; map local to remote projects via ssh/ftp

       :os
       (:if (featurep :system 'macos) macos)  ; improve compatibility with macOS
       ;;tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;beancount         ; mind the GAAP
       (cc +lsp)         ; C > C++ == 1
       (clojure           ; java with a lisp
        +lsp
        +tree-sitter)
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;dhall
       (elixir            ; erlang done right
        +lsp
        +tree-sitter)
       ;;elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       (erlang            ; an elegant language for a more civilized age
        +lsp
        +tree-sitter)
       ;;ess               ; emacs speaks statistics
       ;;factor
       ;;faust             ; dsp, but you get to keep your soul
       ;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       (go
        +lsp         ; the hipster dialect
        +tree-sitter)
       ;;(graphql +lsp)    ; Give queries a REST
       ;;(haskell +lsp)    ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       json              ; At least it ain't XML
       (java             ; the poster child for carpal tunnel syndrome
        +lsp
        +tree-sitter)
       (javascript        ; all(hope(abandon(ye(who(enter(here))))))
        +lsp
        +tree-sitter)
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       ;;latex             ; writing papers in Emacs has never been so fun
       ;;lean              ; for folks with too much to prove
       ;;ledger            ; be audit you can be
       (lua               ; one-based indices? one-based indices
        +fennel
        +lsp
        +tree-sitter)
       markdown          ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       (org               ; organize your plain life in plain text
        +journal
        +pretty
        +roam2)
       ;; (php               ; perl's insecure younger brother
       ;;  +lsp
       ;;  +tree-sitter)
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       ;; (python            ; beautiful is better than ugly
       ;;  +lsp
       ;;  +tree-sitter
       ;;  +poetry)
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       (ruby             ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
        +rails
        +tree-sitter)
       (rust        ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
        +lsp
        +tree-sitter)
       ;;scala             ; java, but good
       ;;(scheme +guile)   ; a fully conniving family of lisps
       sh                ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       (web               ; the tubes
        +lsp
        +tree-sitter)
       ;;yaml              ; JSON, but readable
       (zig               ; C, but simpler
        +lsp
        +tree-sitter)

       :email
       ;;(mu4e +org +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;emms
       everywhere        ; *leave* Emacs!? You must be joking
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config
       literate
       (default +bindings +smartparens))
#+end_src
* Configuration
:PROPERTIES:
:header-args: :tangle config.el
:END:
** Header
#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src

** Global Constants
*** Shell
My primary shell is =fish= however, non-POSIX shells often inject unreadable (to emacs) output into child processes. We'll use zsh inside most of emacs.
#+begin_src emacs-lisp
(setq shell-file-name (executable-find "zsh"))
#+end_src

With that, I use =vterm= and would still like to use fish inside that.
#+begin_src emacs-lisp
(setq-default vterm-shell (executable-find "fish"))
(setq-default explicit-shell-file-name (executable-find "fish"))
#+end_src
*** Contact Info
#+begin_src emacs-lisp
(setq user-full-name "Evan Riley"
      user-mail-address (rot13 "rina@rinaevyrl.arg"))
#+end_src

*** Authinfo.gpg
Store authinfo in my home directory.
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

*** (Somewhat) Sensible Defaults

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      password-cache-expiry nil                   ; I can trust my computers ... can't I?
      ;; scroll-preserve-screen-position 'always     ; Don't have `point' jump around
      scroll-margin 2                             ; It's nice to maintain a little margin
      display-time-default-load-average nil)      ; I don't think I've ever found this useful

(display-time-mode 1)                             ; Enable time in the mode-line

(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

*** Emacsclient

When opening a new emacsclient, prefer to just reuse currently open workspaces instead of creating a new one.
#+begin_src emacs-lisp
(after! persp-mode
  (setq persp-emacsclient-init-frame-behaviour-override "main"))
#+end_src

*** Customizations
By default changes made via a customization are added to =init.el=. I would rather have these in a seperate file.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

** Visual Settings
*** Font
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "0xProto Nerd Font" :size 17)
      doom-big-font (font-spec :family "OxProto Nerd Font" :size 32)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 17)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :size 22 :weight 'light))
#+end_src

*** Theme
#+begin_src emacs-lisp :tangle packages.el
(unpin! doom-themes)
#+end_src

#+begin_src emacs-lisp
;;(setq doom-theme 'doom-badger)
(setq doom-theme 'doom-earl-grey)
#+end_src

*** Remove titlebar
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(undecorated-round . t))
#+end_src

*** Line Numbers
I have line numbers enabled everywhere, and would prefer if they were relative.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

*** Dashboard
A nice simple Emacs 'E' for our dashboard

#+begin_src emacs-lisp
(defvar fancy-splash-image-directory
  (expand-file-name "misc/splash-images/" doom-private-dir)
  "Directory in which to look for splash image templates.")

(defvar fancy-splash-image-template
  (expand-file-name "emacs-e-template.svg" fancy-splash-image-directory)
  "Default template svg used for the splash image.
Colours are substituted as per `fancy-splash-template-colours'.")
#+end_src

Special named colors can be used as the basis for themeing, with a simple replacement system.
#+begin_src emacs-lisp
(defvar fancy-splash-template-colours
  '(("#111112" :face default   :attr :foreground)
    ("#8b8c8d" :face shadow)
    ("#eeeeef" :face default   :attr :background)
    ("#e66100" :face highlight :attr :background)
    ("#1c71d8" :face font-lock-keyword-face)
    ("#f5c211" :face font-lock-type-face)
    ("#813d9c" :face font-lock-constant-face)
    ("#865e3c" :face font-lock-function-name-face)
    ("#2ec27e" :face font-lock-string-face)
    ("#c01c28" :face error)
    ("#000001" :face ansi-color-black)
    ("#ff0000" :face ansi-color-red)
    ("#ff00ff" :face ansi-color-magenta)
    ("#00ff00" :face ansi-color-green)
    ("#ffff00" :face ansi-color-yellow)
    ("#0000ff" :face ansi-color-blue)
    ("#00ffff" :face ansi-color-cyan)
    ("#fffffe" :face ansi-color-white))
  "Alist of colour-replacement plists.
Each plist is of the form (\"$placeholder\" :doom-color 'key :face 'face).
If the current theme is a doom theme :doom-color will be used,
otherwise the colour will be face foreground.")
#+end_src

If we want to make sure an image is themed, we can look for unrecognized hex strings that are not greyscale.

#+begin_src emacs-lisp
(defun fancy-splash-check-buffer ()
  "Check the current SVG buffer for bad colours."
  (interactive)
  (when (eq major-mode 'image-mode)
    (xml-mode))
  (when (and (featurep 'rainbow-mode)
             (not (bound-and-true-p rainbow-mode)))
    (rainbow-mode 1))
  (let* ((colours (mapcar #'car fancy-splash-template-colours))
         (colourise-hex
          (lambda (hex)
            (propertize
             hex
             'face `((:foreground
                      ,(if (< 0.5
                              (cl-destructuring-bind (r g b) (x-color-values hex)
                                ;; Values taken from `rainbow-color-luminance'
                                (/ (+ (* .2126 r) (* .7152 g) (* .0722 b))
                                   (* 256 255 1.0))))
                           "white" "black")
                      (:background ,hex))))))
         (cn 96)
         (colour-menu-entries
          (mapcar
           (lambda (colour)
             (cl-incf cn)
             (cons cn
                   (cons
                    (substring-no-properties colour)
                    (format " (%s) %s %s"
                            (propertize (char-to-string cn)
                                        'face 'font-lock-keyword-face)
                            (funcall colourise-hex colour)
                            (propertize
                             (symbol-name
                              (plist-get
                               (cdr (assoc colour fancy-splash-template-colours))
                               :face))
                             'face 'shadow)))))
           colours))
         (colour-menu-template
          (format
           "Colour %%s is unexpected! Should this be one of the following?\n
%s
 %s to ignore
 %s to quit"
           (mapconcat
            #'cddr
            colour-menu-entries
            "\n")
           (propertize "SPC" 'face 'font-lock-keyword-face)
           (propertize "ESC" 'face 'font-lock-keyword-face)))
         (colour-menu-choice-keys
          (append (mapcar #'car colour-menu-entries)
                  (list ?\s)))
         (buf (get-buffer-create "*fancy-splash-lint-colours-popup*"))
         (good-colour-p
          (lambda (colour)
            (or (assoc colour fancy-splash-template-colours)
                ;; Check if greyscale
                (or (and (= (length colour) 4)
                         (= (aref colour 1)   ; r
                            (aref colour 2)   ; g
                            (aref colour 3))) ; b
                    (and (= (length colour) 7)
                         (string= (substring colour 1 3)       ; rr =
                                  (substring colour 3 5))      ; gg
                         (string= (substring colour 3 5)       ; gg =
                                  (substring colour 5 7))))))) ; bb
         (prompt-to-replace
          (lambda (target)
            (with-current-buffer buf
              (erase-buffer)
              (insert (format colour-menu-template
                              (funcall colourise-hex target)))
              (setq-local cursor-type nil)
              (set-buffer-modified-p nil)
              (goto-char (point-min)))
            (save-window-excursion
              (pop-to-buffer buf)
              (fit-window-to-buffer (get-buffer-window buf))
              (car (alist-get
                    (read-char-choice
                     (format "Select replacement, %s-%s or SPC: "
                             (char-to-string (caar colour-menu-entries))
                             (char-to-string (caar (last colour-menu-entries))))
                     colour-menu-choice-keys)
                    colour-menu-entries))))))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "#[0-9A-Fa-f]\\{6\\}\\|#[0-9A-Fa-f]\\{3\\}" nil t)
        (recenter)
        (let* ((colour (match-string 0))
               (replacement (and (not (funcall good-colour-p colour))
                                 (funcall prompt-to-replace colour))))
          (when replacement
            (replace-match replacement t t))))
      (message "Done"))))
#+end_src

Since we're going to be generating theme-specific versions of splash images, it would good to have a cache directory.

#+begin_src emacs-lisp
(defvar fancy-splash-cache-dir (expand-file-name "theme-splashes/" doom-cache-dir))
#+end_src

To set up dynamic resizing, weâ€™ll use a list specifying the image height at various frame-height thresholds, with a few extra bells and whistles (such as the ability to change image too).

#+begin_src emacs-lisp
(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "List of plists specifying image sizing states.
Each plist should have the following properties:
- :height, the height of the image
- :min-height, the minimum `frame-height' for image
- :padding, a `+doom-dashboard-banner-padding' (top . bottom) padding
  specification to apply
Optionally, each plist may set the following two properties:
- :template, a non-default template file
- :file, a file to use instead of template")
#+end_src

Now thatâ€™s weâ€™ve set up the customisation approach, we need to work out the mechanics for actually implementing this. To start with, a basic utility function to get the relevant file path.

#+begin_src emacs-lisp
(defun fancy-splash-filename (theme template height)
  "Get the file name for the splash image with THEME and of HEIGHT."
  (expand-file-name (format "%s-%s-%d.svg" theme (file-name-base template) height) fancy-splash-cache-dir))
#+end_src

Now to go about actually generating the images. To adjust the sizing on demand,
we will offer two mechanisms:
1. A special =$height= token which is replaced with the desired height
2. Recognition of =height=100=, in which case =100= will be replaced with the
   desired height and any =width= property will be removed.

#+begin_src emacs-lisp
(defun fancy-splash-generate-image (template height)
  "Create a themed image from TEMPLATE of HEIGHT.
The theming is performed using `fancy-splash-template-colours'
and the current theme."
  (with-temp-buffer
    (insert-file-contents template)
    (goto-char (point-min))
    (if (re-search-forward "$height" nil t)
        (replace-match (number-to-string height) t t)
      (if (re-search-forward "height=\"100\\(?:\\.0[0-9]*\\)?\"" nil t)
          (progn
            (replace-match (format "height=\"%s\"" height) t t)
            (goto-char (point-min))
            (when (re-search-forward "\\([ \t\n]\\)width=\"[\\.0-9]+\"[ \t\n]*" nil t)
              (replace-match "\\1")))
        (warn "Warning! fancy splash template: neither $height nor height=100 not found in %s" template)))
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (let* ((replacement-colour
              (face-attribute (plist-get (cdr substitution) :face)
                              (or (plist-get (cdr substitution) :attr) :foreground)
                              nil 'default))
             (replacement-hex
              (if (string-prefix-p "#" replacement-colour)
                  replacement-colour
                (apply 'format "#%02x%02x%02x"
                       (mapcar (lambda (c) (ash c -8))
                               (color-values replacement-colour))))))
        (while (search-forward (car substitution) nil t)
          (replace-match replacement-hex nil nil))))
    (unless (file-exists-p fancy-splash-cache-dir)
      (make-directory fancy-splash-cache-dir t))
    (let ((inhibit-message t))
      (write-region nil nil (fancy-splash-filename (car custom-enabled-themes) template height)))))
#+end_src

We may as well generate each themeâ€™s appropriate images in bulk.
#+begin_src emacs-lisp
(defun fancy-splash-generate-all-images ()
  "Perform `fancy-splash-generate-image' in bulk."
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image
       (or (plist-get size :template)
           fancy-splash-image-template)
       (plist-get size :height)))))
#+end_src

It would be nice to have a simple check function which will just generate the set of relevant images if needed, and do nothing if they already exist.

#+begin_src emacs-lisp
(defun fancy-splash-ensure-theme-images-exist (&optional height)
  "Ensure that the relevant images exist.
Use the image of HEIGHT to check, defaulting to the height of the first
specification in `fancy-splash-sizes'. If that file does not exist for
the current theme, `fancy-splash-generate-all-images' is called. "
  (unless (file-exists-p
           (fancy-splash-filename
            (car custom-enabled-themes)
            fancy-splash-image-template
            (or height (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-all-images)))
#+end_src

In case we switch out the images used (or something else goes wrong), it would be good to have a convenient method to clear this cache.

#+begin_src emacs-lisp
(defun fancy-splash-clear-cache (&optional delete-files)
  "Clear all cached fancy splash images.
Optionally delete all cache files and regenerate the currently relevant set."
  (interactive (list t))
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (let ((image-file
             (fancy-splash-filename
              (car custom-enabled-themes)
              (or (plist-get size :template)
                  fancy-splash-image-template)
              (plist-get size :height))))
        (image-flush (create-image image-file) t))))
  (message "Fancy splash image cache cleared!")
  (when delete-files
    (delete-directory fancy-splash-cache-dir t)
    (fancy-splash-generate-all-images)
    (message "Fancy splash images cache deleted!")))
#+end_src

In a similar way, it could be fun to allow for switching the template used. We
can support this by looking for files ending in =-template.svg= and running
~image-flush~ via ~fancy-splash-clear-cache~.

#+begin_src emacs-lisp
(defun fancy-splash-switch-template ()
  "Switch the template used for the fancy splash image."
  (interactive)
  (let ((new (completing-read
              "Splash template: "
              (mapcar
               (lambda (template)
                 (replace-regexp-in-string "-template\\.svg$" "" template))
               (directory-files fancy-splash-image-directory nil "-template\\.svg\\'"))
              nil t)))
    (setq fancy-splash-image-template
          (expand-file-name (concat new "-template.svg") fancy-splash-image-directory))
    (fancy-splash-clear-cache)
    (message "") ; Clear message from `fancy-splash-clear-cache'.
    (setq fancy-splash--last-size nil)
    (fancy-splash-apply-appropriate-image)))
#+end_src


Now we can ensure that the desired images exist, we need to work out which particular one we want. This is really just a matter of comparing the frame height to the set of presets.

#+begin_src emacs-lisp
(defun fancy-splash-get-appropriate-size ()
  "Find the firt `fancy-splash-sizes' with min-height of at least frame height."
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))
#+end_src

We now want to apply the appropriate image to the dashboard. At the same time, we donâ€™t want to do so needlessly, so we may as well record the size and theme to determine when a refresh is actually needed.


#+begin_src emacs-lisp
(setq fancy-splash--last-size nil)
(setq fancy-splash--last-theme nil)

(defun fancy-splash-apply-appropriate-image (&rest _)
  "Ensure the appropriate splash image is applied to the dashboard.
This function's signature is \"&rest _\" to allow it to be used
in hooks that call functions with arguments."
  (let ((appropriate-size (fancy-splash-get-appropriate-size)))
    (unless (and (equal appropriate-size fancy-splash--last-size)
                 (equal (car custom-enabled-themes) fancy-splash--last-theme))
      (unless (plist-get appropriate-size :file)
        (fancy-splash-ensure-theme-images-exist (plist-get appropriate-size :height)))
      (setq fancy-splash-image
            (or (plist-get appropriate-size :file)
                (fancy-splash-filename (car custom-enabled-themes)
                                       fancy-splash-image-template
                                       (plist-get appropriate-size :height)))
            +doom-dashboard-banner-padding (plist-get appropriate-size :padding)
            fancy-splash--last-size appropriate-size
            fancy-splash--last-theme (car custom-enabled-themes))
      (+doom-dashboard-reload))))
#+end_src

If we're operating in a terminal (or =emacclient=) we see an ascii banner instead
of the graphical one. I'd also like to use something simple for this.

#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(",---.,-.-.,---.,---.,---."
            "|---'| | |,---||    `---."
            "`---'` ' '`---^`---'`---'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))
#+end_src


Now we just need this as Doom's ASCII banner function.
#+begin_src emacs-lisp
(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

Let's start off by setting the local folder to put the phrase source files in.
#+begin_src emacs-lisp
(defvar splash-phrase-source-folder
  (expand-file-name "misc/splash-phrases" doom-private-dir)
  "A folder of text files with a fun phrase on each line.")
#+end_src

Now we want to support two "phrase systems"
1. A complete file of phrases, one phrase per line
2. A collection of phrase-components, put together to form a phrase

It would be good to specify/detect which of the two cases apply based on the
file name alone. I've done this by setting the simple check that if the file
name contains =-N-= (where =N= is some number) then it is taken as the =N=â€‹th phrase
component, with everything preceding the =-N-= token taken as the collection
identifier, and everything after =-N-= ignored.
#+begin_src emacs-lisp
(defvar splash-phrase-sources
  (let* ((files (directory-files splash-phrase-source-folder nil "\\.txt\\'"))
         (sets (delete-dups (mapcar
                             (lambda (file)
                               (replace-regexp-in-string "\\(?:-[0-9]+-\\w+\\)?\\.txt" "" file))
                             files))))
    (mapcar (lambda (sset)
              (cons sset
                    (delq nil (mapcar
                               (lambda (file)
                                 (when (string-match-p (regexp-quote sset) file)
                                   file))
                               files))))
            sets))
  "A list of cons giving the phrase set name, and a list of files which contain phrase components.")
#+end_src

Let's fix the phrase set in use, and pick a random phrase source on startup.
#+begin_src emacs-lisp
(defvar splash-phrase-set
  (nth (random (length splash-phrase-sources)) (mapcar #'car splash-phrase-sources))
  "The default phrase set. See `splash-phrase-sources'.")
#+end_src

While having a random set of phrases is fantastic the vast majority of the time,
I expect that occasionally I'll feel in the mood to change the phrase set or
pick a particular one, so some functions for that would be nice.
#+begin_src emacs-lisp
(defun splash-phrase-set-random-set ()
  "Set a new random splash phrase set."
  (interactive)
  (setq splash-phrase-set
        (nth (random (1- (length splash-phrase-sources)))
             (cl-set-difference (mapcar #'car splash-phrase-sources) (list splash-phrase-set))))
  (+doom-dashboard-reload t))

(defun splash-phrase-select-set ()
  "Select a specific splash phrase set."
  (interactive)
  (setq splash-phrase-set (completing-read "Phrase set: " (mapcar #'car splash-phrase-sources)))
  (+doom-dashboard-reload t))
#+end_src

If we're going to be selecting phrases from a large list of lines, it could be
worth caching the list of lines.
#+begin_src emacs-lisp
(defvar splash-phrase--cached-lines nil)
#+end_src

Now let's write a function that will pick a random line from a file, using
~splash-phrase--cached-lines~ if possible.
#+begin_src emacs-lisp
(defun splash-phrase-get-from-file (file)
  "Fetch a random line from FILE."
  (let ((lines (or (cdr (assoc file splash-phrase--cached-lines))
                   (cdar (push (cons file
                                     (with-temp-buffer
                                       (insert-file-contents (expand-file-name file splash-phrase-source-folder))
                                       (split-string (string-trim (buffer-string)) "\n")))
                               splash-phrase--cached-lines)))))
    (nth (random (length lines)) lines)))
#+end_src

With this, we now have enough to generate random phrases on demand.
#+begin_src emacs-lisp
(defun splash-phrase (&optional set)
  "Construct a splash phrase from SET. See `splash-phrase-sources'."
  (mapconcat
   #'splash-phrase-get-from-file
   (cdr (assoc (or set splash-phrase-set) splash-phrase-sources))
   " "))
#+end_src

I originally thought this might be enough, but some phrases are a tad long, and
this isn't exactly doom-dashboard appropriate. In such cases we need to split
lines, re-centre them, and add some whitespace. While we're at it, we may as
well make it that you can click on the phrase to replace it with new one.
#+begin_src emacs-lisp
(defun splash-phrase-dashboard-formatted ()
  "Get a splash phrase, flow it over multiple lines as needed, and fontify it."
  (mapconcat
   (lambda (line)
     (+doom-dashboard--center
      +doom-dashboard--width
      (with-temp-buffer
        (insert-text-button
         line
         'action
         (lambda (_) (+doom-dashboard-reload t))
         'face 'doom-dashboard-menu-title
         'mouse-face 'doom-dashboard-menu-title
         'help-echo "Random phrase"
         'follow-link t)
        (buffer-string))))
   (split-string
    (with-temp-buffer
      (insert (splash-phrase))
      (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
      (fill-region (point-min) (point-max))
      (buffer-string))
    "\n")
   "\n"))
#+end_src

Almost there now, this just needs some centreing and newlines.
#+begin_src emacs-lisp
(defun splash-phrase-dashboard-insert ()
  "Insert the splash phrase surrounded by newlines."
  (insert "\n" (splash-phrase-dashboard-formatted) "\n"))
#+end_src

When using the dashboard, there are often a small number of actions I will take.
As the dashboard is it's own major mode, there is no need to suffer the tyranny
of unnecessary keystrokes --- we can simply bind common actions to a single key!
#+begin_src emacs-lisp
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ng "f" #'find-file
        :desc "Recent files" :ng "r" #'consult-recent-file
        :desc "Config dir" :ng "C" #'doom/open-private-config
        :desc "Open config.org" :ng "c" (cmd! (find-file (expand-file-name "config.org" doom-user-dir)))
        :desc "Open org-mode root" :ng "O" (cmd! (find-file (expand-file-name "lisp/org/" doom-user-dir)))
        :desc "Open dotfile" :ng "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ng "n" #'org-roam-node-find
        :desc "Switch buffer" :ng "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ng "B" #'consult-buffer
        :desc "IBuffer" :ng "i" #'ibuffer
        :desc "Previous buffer" :ng "p" #'previous-buffer
        :desc "Set theme" :ng "t" #'consult-theme
        :desc "Quit" :ng "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ng "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

Unfortunately the show keybindings help doesn't currently work as intended, but
this is still quite nice overall.

Now that the dashboard is so convenient, I'll want to make it easier to get to.
#+begin_src emacs-lisp
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src

With the splash image and phrase generation worked out, we can almost put
together the desired dashboard from scratch, we just need to re-create the
benchmark information by itself.
#+begin_src emacs-lisp
(defun +doom-dashboard-benchmark-line ()
  "Insert the load time line."
  (when doom-init-time
    (insert
     "\n\n"
     (propertize
      (+doom-dashboard--center
       +doom-dashboard--width
       (doom-display-benchmark-h 'return))
      'face 'doom-dashboard-loaded))))
#+end_src

With ~doom-display-benchmark-h~ displayed here, I don't see the need for it to be
shown in the minibuffer as well.
#+begin_src emacs-lisp
(remove-hook 'doom-after-init-hook #'doom-display-benchmark-h)
#+end_src

Now we can create the desired dashboard by setting ~+doom-dashboard-functions~ to
just have:
+ The "widget banner" (splash image)
+ The benchmark line
+ A random phrase
This gets rid of two segments I'm not particularly interested in seeing
+ The shortmenu
+ The footer (github link)
#+begin_src emacs-lisp
(setq +doom-dashboard-functions
      (list #'doom-dashboard-widget-banner
            #'+doom-dashboard-benchmark-line
            #'splash-phrase-dashboard-insert))
#+end_src



The end result is a minimal but rather nice splash screen.

To keep the splash image up to date, we just need to check it every time the
frame size or theme is changed.

#+begin_src emacs-lisp
(add-hook 'window-size-change-functions #'fancy-splash-apply-appropriate-image)
(add-hook 'doom-load-theme-hook #'fancy-splash-apply-appropriate-image)
#+end_src

** Company
Reduce prefix length and elay. This may cause performance issues.
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.2
        company-minimum-prefix-length 1))
#+end_src

Increase the file watch threshold from 1000 to 1500.

#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-file-watch-threshold 1500))
#+end_src

** Editing
Enable easy use of =avy=
#+begin_src emacs-lisp
(map! "C-'" #'avy-goto-char-timer)
#+end_src

Reduce avy timeout from 0.5, because I'm impatient.
#+begin_src emacs-lisp
(after! avy
  (setq avy-timeout-seconds 0.3))
#+end_src

Use =comment-dwim=

#+begin_src emacs-lisp :tangle packages.el
(package! comment-dwim-2 :pin "7cdafd6d98234a7402865b8abdae54a2f2551c94")
#+end_src

#+begin_src emacs-lisp
(use-package! comment-dwim-2
  :bind ([remap comment-dwim] . comment-dwim-2)
  :config (setq cd2/region-command 'cd2/comment-or-uncomment-region))
#+end_src

** Org-Mode
*** General
Set org directory

#+begin_src emacs-lisp
(setq org-directory "~/Documents/Org/")
#+end_src

Set the org-agenda files to be in the org directory.
#+begin_src emacs-lisp
(defvar org-agenda-files nil)
(add-to-list 'org-agenda-files org-directory)
#+end_src

What follows will be a lot of org configuration

#+begin_src emacs-lisp
(after! org
(setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "ONHOLD(h)" "|" "DONE(d)")
                          (sequence "EMAIL(e)" "|" "SENT(s)")
                          (sequence "|" "CANCELLED(c)")
                          (sequence "|" "MOVED(m)")))

(setq org-enforce-todo-dependencies t)
(setq org-return-follows-link t)
(setq org-highlight-latex-and-related '(native script entities))
(setq org-startup-with-latex-preview nil
      org-startup-with-inline-images nil)

(map! :map org-mode-map "C-'" nil)

(map! :map evil-org-mode-map
      :n "zf" #'org-toggle-latex-fragment)
  )

(defun tq/org-exit-link-forward ()
  "Jump just outside a link forward"
  (interactive)
  (when (org-in-regexp org-link-any-re)
    (goto-char (match-end 0))
    (insert " ")))

(defun tq/org-exit-link-backward ()
  "Jump just outside a link backward"
  (interactive)
  (when (org-in-regexp org-link-any-re)
    (goto-char (match-beginning 0))
    (save-excursion (insert " "))))

(map! :map (evil-org-mode-map org-mode-map)
      :ni "C-k" #'tq/org-exit-link-forward
      :ni "C-j" #'tq/org-exit-link-backward)
#+end_src

Archive to subdirectory and use datetree
#+begin_src emacs-lisp
(after! org-archive
  (setq org-archive-location "archive/%s_archive::datetree/"))
#+end_src

Remove empty clock lines, they achieve nothing.
#+begin_src emacs-lisp
(after! org-clock
  (setq org-clock-out-remove-zero-time-clocks t))
#+end_src

*** Capture
Bind capture to something more convient.
#+begin_src emacs-lisp
(map! :leader "j" #'org-capture)
#+end_src

Configure the capture templates

#+begin_src emacs-lisp
(defadvice! tq/setup-capture-templates ()
  :after #'+org-init-capture-defaults-h
  (setq org-default-notes-file (expand-file-name "inbox.org" org-directory))

  (setq org-capture-templates
        `(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?")
          ("a" "appointment" entry (file org-default-notes-file)
           "* %?")
          ("j" "journal" plain (file+olp+datetree ,(concat org-directory "journal.org"))
           (file ,(concat org-directory "templates/journal.org"))
           :immediate-finish t :jump-to-captured t :tree-type 'week)
          ("w" "workout" plain
           (file+olp+datetree ,(concat org-directory "exercise.org") "Workouts")
           (file ,(concat org-directory "templates/workout.org"))
           :immediate-finish t :jump-to-captured t :tree-type 'week))))
#+end_src

*** Org-Roam(2)

Set directory for =org-roam2= notes

#+begin_src emacs-lisp
(setq org-roam-directory (concat (file-name-as-directory org-directory) "Notes/"))
#+end_src

Put the database in the doom cache directory, rather than with the notes.

#+begin_src emacs-lisp
(setq org-roam-db-location (concat doom-cache-dir "org-roam.db"))
#+end_src

Turn off verbosity

#+begin_src emacs-lisp
(setq org-roam-verbose nil)
#+end_src

Ensure tags come from both the directory and =roam_tag= file property. The default is just the property.
#+begin_src emacs-lisp
(setq org-roam-tag-sources '(prop all-directories))
#+end_src

Set the dailies directroy to be a subdirectory in my base =org-roam= directory.
#+begin_src emacs-lisp
(setq org-roam-tag-sources '(prop all-directories))
#+end_src

Set the capture template for my daily notes.
#+begin_src emacs-lisp
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry "* %?"
         :if-new (file+head
                  "%<%Y-%m-%d>.org"
                  "#+title: %<%Y-%m-%d>\n")
         :unnarrowed t
         :immediate-finish t
         :jump-to-captured t)))
#+end_src

Update the database immediately on file changes. The alternative is to do it on an idle timer, but I've found that to be buggy.
#+begin_src emacs-lisp
(setq org-roam-db-update-method 'immediate)
#+end_src

Set up an agenda view for nearby notes.
#+begin_src emacs-lisp
(defun tq/org-agenda-nearby-notes (&optional distance)
  (interactive "P")
  (let ((org-agenda-files (org-roam-db--links-with-max-distance
                           buffer-file-name (or distance 3)))
        (org-agenda-custom-commands '(("e" "" ((alltodo ""))))))
    (org-agenda nil "e")))

(map! :leader :prefix "n" :desc "Agenda nearby" "a" #'tq/org-agenda-nearby-notes)
#+end_src

Setup case-insensitive completion in org-roam files.
#+begin_src emacs-lisp
(add-hook! 'org-roam-file-setup-hook
  (setq-local completion-ignore-case t))
#+end_src

Rename files whne the tile is changed.
#+begin_src emacs-lisp
(add-hook! 'after-save-hook
           (defun org-rename-to-new-title ()
             (when-let*
                 ((old-file (buffer-file-name))
                  (is-roam-file (org-roam-file-p old-file))
                  (in-roam-base-directory? (string-equal
                                            (expand-file-name org-roam-directory)
                                            (file-name-directory old-file)))
                  (file-node (save-excursion
                               (goto-char 1)
                               (org-roam-node-at-point)))
                  (slug (org-roam-node-slug file-node))
                  (new-file (expand-file-name (concat slug ".org")))
                  (different-name? (not (string-equal old-file new-file))))
               (rename-buffer new-file)
               (rename-file old-file new-file)
               (set-visited-file-name new-file)
               (set-buffer-modified-p nil))))
#+end_src

Configure the web ui
#+begin_src emacs-lisp
(use-package org-roam-ui
  :after org-roam
  :hook (after-init . org-roam-ui-mode))
#+end_src

** Languages
Settings and extra packages not included in doom emacs
*** Python
Set up LSP to turn off some python warnings
#+begin_src emacs-lisp
(after! python
  (setq! lsp-pylsp-plugins-pydocstyle-ignore t))
#+end_src

*** Go
Disable go-eldoc
#+begin_src emacs-lisp :tangle packages.el
(package! go-eldoc :disable t)
#+end_src

Use goimports as our formatter
#+begin_src emacs-lisp
(setq gofmt-command "goimports")
(add-hook 'before-save-hook 'gofmt-before-save)
#+end_src
